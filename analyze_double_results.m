function [ results ] = analyze_double_results( double_KOs_results )
%ANALYZE_DOUBLE_RESULTS compares model double KO biomass flux predictions
%to SGD-annotated "synthetic lethal" gene pairs. 
%
%   This function processes the XX_double_KOs structure generated by the
%   testDoubles.m function and requires the 'SGD synthetic lethals.mat'
%   file generated as described below.

%% acknowledgments and download instructions
% thanks to Rama Balakrishnan, of SGD, for providing these instructions for
% finding synthetic lethal interactions on SGD.
%
% "Thanks for writing in. Sure, we can build this kind of query using
% YeastMine. I have provided instructions below to retrieve all gene pairs
% of genes that interact genetically and are either 'Synthetic Rescue' or
% Synthetic lethality'.
% 
% 1) Click on the Query Builder option on the tool bar of YeastMine
% homepage (yeastmine.yeastgenome.org) 2) Click on the 'Import query from
% XML' link available in the Querybuilder box on the left corner. 3) Paste
% the following XML in the text box and hit submit.
% 
% <query name="" model="genomic" view="Interaction.gene1.primaryIdentifier
% Interaction.gene1.secondaryIdentifier Interaction.gene2.primaryIdentifier
% Interaction.gene2.secondaryIdentifier Interaction.details.annotationType
% Interaction.details.experimentType Interaction.details.phenotype
% Interaction.details.type" longDescription=""
% sortOrder="Interaction.gene1.primaryIdentifier asc">
%   <constraint path="Interaction.details.experimentType" op="="
%   value="Synthetic Lethality"/>
% </query>
% 
% 4) You will now land on a Model browser page which shows the query model.
% Click on the green Show Results page and you should get a list of
% interacting genes where experiment type = 'Synthetic Lethality'
% 
% 5) To get a list of interacting genes with Synthetic rescue type, go back
% to step 3, and paste the following XML and follow step 4.
% 
% <query name="" model="genomic" view="Interaction.gene1.primaryIdentifier
% Interaction.gene1.secondaryIdentifier Interaction.gene2.primaryIdentifier
% Interaction.gene2.secondaryIdentifier Interaction.details.annotationType
% Interaction.details.experimentType Interaction.details.phenotype
% Interaction.details.type" longDescription=""
% sortOrder="Interaction.gene1.primaryIdentifier asc">
%   <constraint path="Interaction.details.experimentType" op="="
%   value="Synthetic Rescue"/>
% </query>
% "

% After following these instructions, I processed the downloaded report
% thus:
% 
% fid=fopen('SGD synthetic lethal.txt')
% 
% A = cell(0,2);
% 
% while ~feof(fid)
%     tline = fgetl(fid);
%     tline = textscan(tline,'%s','delimiter','\t');
%     %tline is
%     %{[gene1][gene2][screentype][experiment][phenotype][interaction]}
%     A(end+1,1) = tline{1}(1); 
%     A(end,2) = tline{1}(2);
% end
% 
% save('SGD synthetic lethals','A');
% 
% fclose(fid);

    load('results/SGD synthetic lethals.mat');
    
    B = double_KOs_results(:,1:2);
    C = union(A, B) ;
    
    [~,ai] = ismember(A,C) ;
    [~,bi] = ismember(B,C) ;
    [tf,loc] = ismember(ai,bi,'rows'); % so A(1,:) == B(loc(1),:)
    
    % this is a bit painful, but there are duplicates in the SGD synthetic
    % lethals list, so some of the pairs appear on the list twice (for
    % example, A(701:702,:). We want the unique doubles. So
    % double_KOs_results(unique(loc(logical(loc))),:) is the rows of
    % doubles included in the SGD list of synthetic leathals. Each row from
    % a 100% correct specific and accurate model would contain 2 gene
    % names, a prediction of a biomass flux for each single deletion, and a
    % prediction of no biomass flux for the double deletion
    
    % binarize the biomass flux predictions. Arbitrarily choose a threshold
    % of 10% of predicted WT biomass flux as "lethal".
    
    % first, bugchecking fix - some knockout predictions generated by the
    % testDoubles script may match multiple genes, so the predicted biomass
    % fluxes are not single values, but rather one for each gene. In such
    % cases, check that all biomass flux values are the same, and replace
    % the vector with the value.
    
    for column=3:5

        big = cellfun(@length, double_KOs_results(:, column)) > 1;

        error_index = find(big);

        for index = 1:length(error_index)
            if length((double_KOs_results{error_index(1), column})) > 2
                
                warning('More than two genes match at error_index %i.\n', ...
                    error_index)
            else
                % if the two matches have the same predicted biomass flux,
                % replace the matrix with the single value
                if double_KOs_results{error_index(index), column}(1) - ...
                        double_KOs_results{error_index(index), column}(2) < 0.001
                    
                    double_KOs_results{error_index(index), column} = ...
                        double_KOs_results{error_index(index), column}(1);
                    
                % and if they're different, but both nonzero, warn and take
                % the average
                else
                    warning('The biomass flux predictions differ at error_index %i.\n', ...
                        error_index);
                    
                    if double_KOs_results{error_index(index), column}(1) ...
                            < .001 | ...
                            double_KOs_results{error_index(index), ...
                            column}(1) < .001
                        error('One of the matches has zero biomass flux.');
                    else
                        double_KOs_results{error_index(index), column} = ...
                            (double_KOs_results{error_index(index), ...
                            column}(1) + ...
                            double_KOs_results{error_index(index), ...
                            column}(2)) / 2;
                    end
                end
            end
        end
    end
    
    
    model_prediction = cell2mat(double_KOs_results(:,3)) > 0.1;
    model_prediction = [model_prediction ...
        cell2mat(double_KOs_results(:,4)) > 0.1];
    model_prediction = [model_prediction ...
        cell2mat(double_KOs_results(:,5)) > 0.1];
    
    model_prediction = logical(model_prediction);
    
    % number = the number of SGD synthetic lethals that are included in the
    % model 2KO simulation (this is the reference "known" synthetic lethal
    % number)
    known_lethals = model_prediction(unique(loc(logical(loc))),:);   
    results.number_known_lethals = length(known_lethals);
    results.number_model_pairs = length(B);
    
    % true positives = for a gene pair that is included in the SGD list,
    % the model correctly predicts neither gene is essential by itself, and
    % the pair is essential
    
    results.tp = sum(ismember(known_lethals, [1 1 0], 'rows')); 
    
    % true negative = for a gene pair that is not included in the SGD list,
    % and for which the model correctly predicts neither gene is essential
    % by itself, the model correctly predicts that the pair is not
    % essential (note: if the model incorrectly predicts that either gene
    % is essential by itself, that should show up in single deletion
    % metrics, and such cases are less interesting with regard to synthetic
    % lethal predictive performance)
    
    % first build the list of pairs of genes screeened that are not
    % included in the SGD list. This is the reference list of "known" not
    % synthetic lethal
    known_not_lethal = zeros(length(B),1);
    entries = loc(logical(loc));
    known_not_lethal(entries) = 1;
    known_not_lethal = ~known_not_lethal;
    
    known_not_lethal = model_prediction(known_not_lethal,:);
    
    results.tn = sum(ismember(known_not_lethal, [1 1 1], 'rows'));
    
    % false positive double = model incorrectly predicts that neither gene
    % is essential by itself, and the pair is essential
    results.fp = sum(ismember(known_not_lethal, [1 1 0], 'rows'));
       
    % false negative double = model correctly predicts that neither gene is
    % essential by itself, but incorrectly predicts that the pair is not
    % essential
    results.fn = sum(ismember(known_lethals, [1 1 1], 'rows'));
    
    % others_error = model incorrectly predicts that one or both of the
    % genes are essential by themselves
    results.other_error = ...
        sum(ismember(model_prediction, [1 0 1], 'rows')) + ...
        sum(ismember(model_prediction, [0 1 1], 'rows')) + ...
        sum(ismember(model_prediction, [1 0 0], 'rows')) + ...
        sum(ismember(model_prediction, [0 1 0], 'rows')) + ...
        sum(ismember(model_prediction, [0 0 1], 'rows')) + ...
        sum(ismember(model_prediction, [0 0 0], 'rows'));
    
    if results.tp + results.tn + results.fp + results.fn + ...
            results.other_error ~= results.number_model_pairs
        warning('Not all model pairs accounted for in error analysis');
    end
    
    % calculate the sensitivity, specificity, positive and negative
    % predictive values, geometric mean accuracy, and Matthews' Correlation
    % Coefficient for double KO predictions
    results.sensitivity = results.tp / (results.tp + results.fn);
    results.specificity = results.tn / (results.tn + results.fp);
    results.ppv = results.tp / (results.tp + results.fp);
    results.npv = results.tn / (results.tn + results.fn);
    results.gma = sqrt(results.sensitivity * results.specificity);
    results.mcc = (results.tp * results.tn - results.fp * results.fn) / ...
        sqrt((results.tp + results.fp) * (results.tp + results.fn) * ...
        (results.tn + results.fp) * (results.tn + results.fn));
end

